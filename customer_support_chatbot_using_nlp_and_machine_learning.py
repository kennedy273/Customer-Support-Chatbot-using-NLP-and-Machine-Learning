# -*- coding: utf-8 -*-
"""Customer Support Chatbot using NLP and Machine Learning

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OWZJLrRLLAheVJlT6sSIY_ygnIRiQM9R

# Natural Language Processing Techniques for Text Classification

Natural Language Processing (NLP) is a technique used to process human language. In this project, we will implement several NLP techniques for text classification using Python's Natural Language Toolkit (NLTK). The techniques include tokenization, stopword removal, tagging, lemmatization, and stemming.
"""

import nltk
from nltk.tokenize import word_tokenize, sent_tokenize
from nltk.corpus import stopwords
from nltk.stem import PorterStemmer, WordNetLemmatizer

# Download necessary NLTK data files (run once)
nltk.download('punkt')
nltk.download('stopwords')
nltk.download('averaged_perceptron_tagger')
nltk.download('wordnet')
nltk.download('punkt_tab') # Download punkt_tab resource
nltk.download('averaged_perceptron_tagger_eng')

# Example text
text = "My internet connection is not working properly. I need a refund for my payment."

# 1. Tokenization
# Sentence Tokenization
sent_tokens = sent_tokenize(text)
print("Sentence Tokens:", sent_tokens)

# Word Tokenization
word_tokens = word_tokenize(text)
print("Word Tokens:", word_tokens)

# 2. Stopword Removal
stop_words = set(stopwords.words('english'))
filtered_words = [word for word in word_tokens if word.lower() not in stop_words]
print("Filtered Words (Stopword Removal):", filtered_words)

# 3. Part-of-Speech (POS) Tagging
pos_tags = nltk.pos_tag(filtered_words)
print("POS Tags:", pos_tags)

# 4. Stemming
stemmer = PorterStemmer()
stems = [stemmer.stem(w) for w in filtered_words]
print("After Stemming:", stems)

# 5. Lemmatization
lemmatizer = WordNetLemmatizer()
lemmas = [lemmatizer.lemmatize(w) for w in filtered_words]
print("After Lemmatization:", lemmas)

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.tree import DecisionTreeClassifier
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score

"""# After implementing NLP techniques, we will build a model using two popular classifiers - Decision Tree and Naive Bayes.
 Decision Tree Classifier creates a tree where each node is a feature name, and each branch defines the feature value. Naive Bayes is a simpler algorithm that sets a basic baseline accuracy model.
"""

# Example dataset (queries + categories)
training_data = [
    ("My internet is not working", "technical support"),
    ("The app keeps crashing", "technical support"),
    ("I want to change my payment method", "billing"),
    ("I was charged twice this month", "billing"),
    ("Where is my package?", "shipping"),
    ("My order hasn’t arrived yet", "shipping"),
    ("Refund my money please", "billing"),
    ("How do I reset my password?", "technical support")
]
# Separate inputs and labels
corpus = [q for (q, a) in training_data]
labels = [a for (q, a) in training_data]

# Convert text into numerical features (Bag of Words)
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(corpus)

# --- 1. Train Naive Bayes Classifier ---
nb_model = MultinomialNB()
nb_model.fit(X, labels)

# --- 2. Train Decision Tree Classifier ---
dt_model = DecisionTreeClassifier()
dt_model.fit(X, labels)

# --- Test Data ---
test_queries = [
    "I need a refund for my payment",
    "The app is not opening",
    "When will my order arrive?"
]

X_test = vectorizer.transform(test_queries)

# Predictions
print("Naive Bayes Predictions:", nb_model.predict(X_test))
print("Decision Tree Predictions:", dt_model.predict(X_test))

# --- Evaluate Accuracy (Optional) ---
# Train-test split (for evaluation)
from sklearn.model_selection import train_test_split

X_train, X_val, y_train, y_val = train_test_split(X, labels, test_size=0.3, random_state=42)

nb_model.fit(X_train, y_train)
dt_model.fit(X_train, y_train)

print("Naive Bayes Accuracy:", accuracy_score(y_val, nb_model.predict(X_val)))
print("Decision Tree Accuracy:", accuracy_score(y_val, dt_model.predict(X_val)))

"""# After building the initial models, we will fine-tune them by adjusting hyperparameters.
 Hyperparameters are configuration variables that determine the behavior of the algorithms. This project will focus on tuning two hyperparameters - Entropy cutoff and Support cutoff
"""

from sklearn.model_selection import GridSearchCV

# --- Fine-tuning Decision Tree ---
dt_params = {
    "criterion": ["entropy", "gini"],   # Which impurity measure to use
    "max_depth": [2, 3, 5, None],       # How deep the tree can grow
    "min_samples_split": [2, 3, 5],     # Minimum samples to split a node
    "min_samples_leaf": [1, 2, 3]       # Minimum samples in a leaf
}

dt_grid = GridSearchCV(DecisionTreeClassifier(), dt_params, cv=3)
dt_grid.fit(X, labels)

print("Best Decision Tree Params:", dt_grid.best_params_)
print("Best Decision Tree Score:", dt_grid.best_score_)

# --- Fine-tuning Naive Bayes ---
nb_params = {
    "alpha": [0.1, 0.5, 1.0],   # Smoothing factor
}

nb_grid = GridSearchCV(MultinomialNB(), nb_params, cv=3)
nb_grid.fit(X, labels)

print("Best Naive Bayes Params:", nb_grid.best_params_)
print("Best Naive Bayes Score:", nb_grid.best_score_)

# --- Try with min_df and max_df in CountVectorizer ---
vectorizer = CountVectorizer(min_df=1, max_df=0.8)
X = vectorizer.fit_transform(corpus)

!pip install streamlit

import streamlit as st
import nltk
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
from nltk.tokenize import word_tokenize

# Download NLTK resources
nltk.download("punkt")
nltk.download("stopwords")
nltk.download("wordnet")

# --- NLP Setup ---
lemmatizer = WordNetLemmatizer()
stop_words = set(stopwords.words("english"))

def preprocess(text):
    tokens = word_tokenize(text.lower())
    tokens = [lemmatizer.lemmatize(word) for word in tokens if word.isalpha() and word not in stop_words]
    return tokens

# Categories
categories = {
    "billing": ["refund", "payment", "invoice", "bill", "price", "premium"],
    "shipping": ["shipping", "delivery", "package", "order", "tracking"],
    "technical support": ["error", "crash", "bug", "issue", "problem", "device"],
    "pricing": ["price", "cost", "premium", "subscription", "plan", "difference", "compare"],
}

# Responses
responses = {
    "billing": "💳 I understand you have a billing issue. Can you provide your order ID?",
    "shipping": "📦 Looks like a shipping issue. Can you share your tracking number?",
    "technical support": "🛠️ It looks like a technical issue. Can you tell me which device you are using?",
    "pricing": "💰 Our Premium plan is $10/month and Standard plan is $5/month.",
    "pricing_diff": "📊 The Standard plan gives you basic features for $5/month, while Premium offers advanced features, faster support, and extra tools for $10/month.",
    "default": "🤔 Sorry, I’m not sure about that. Could you rephrase?",
}

# Classification
def classify(text):
    tokens = preprocess(text)

    # Special handling for pricing comparison
    if any(word in text.lower() for word in ["difference", "compare", "vs", "better"]):
        return "pricing_diff"

    scores = {cat: 0 for cat in categories}
    for cat, keywords in categories.items():
        for word in tokens:
            if word in keywords:
                scores[cat] += 1
    return max(scores, key=scores.get) if max(scores.values()) > 0 else "default"

# --- Streamlit App ---
st.set_page_config(page_title="Smart Chatbot", page_icon="🤖", layout="centered")
st.title("💬 Customer Support Chatbot")

# Initialize session
if "messages" not in st.session_state:
    st.session_state.messages = []
if "awaiting_order_id" not in st.session_state:
    st.session_state.awaiting_order_id = False
if "awaiting_tracking_id" not in st.session_state:
    st.session_state.awaiting_tracking_id = False

# Show chat history
for sender, msg in st.session_state.messages:
    if sender == "You":
        st.markdown(f"**🧑 You:** {msg}")
    else:
        st.markdown(f"**🤖 Bot:** {msg}")

# --- Chat input ---
user_input = st.chat_input("Type your message...")

if user_input:
    st.session_state.messages.append(("You", user_input))

    # --- Refund Order ID Flow ---
    if st.session_state.awaiting_order_id:
        if user_input.isdigit():
            st.session_state.messages.append(("Bot", "✅ I have forwarded your refund request. You will get a notification in 2 - 3 days."))
            st.session_state.messages.append(("Bot", "ℹ️ Is there anything else I can help you with?"))
            st.session_state.awaiting_order_id = False
        else:
            st.session_state.messages.append(("Bot", "❌ That doesn’t look like a valid order ID. Please enter a number."))

    # --- Shipping Tracking ID Flow ---
    elif st.session_state.awaiting_tracking_id:
        if user_input.isdigit():
            st.session_state.messages.append(("Bot", f"📦 Tracking ID {user_input} found. Your package is being processed."))
            st.session_state.messages.append(("Bot", "ℹ️ Is there anything else I can help you with?"))
            st.session_state.awaiting_tracking_id = False
        else:
            st.session_state.messages.append(("Bot", "❌ That doesn’t look like a valid tracking number. Please enter digits only."))

    else:
        if user_input.lower() in ["quit", "exit"]:
            st.session_state.messages.append(("Bot", "👋 Goodbye!"))
        else:
            category = classify(user_input)
            bot_response = responses.get(category, responses["default"])
            st.session_state.messages.append(("Bot", bot_response))

            # If refund detected → wait for order ID next
            if category == "billing" and "refund" in user_input.lower():
                st.session_state.awaiting_order_id = True

            # If shipping detected → wait for tracking ID next
            if category == "shipping":
                st.session_state.awaiting_tracking_id = True

    st.rerun()

# --- Quick Reply Buttons ---
st.subheader("Quick Replies")
col1, col2, col3, col4, col5 = st.columns(5)

if col1.button("💳 Billing"):
    st.session_state.messages.append(("You", "I have a billing issue"))
    st.session_state.messages.append(("Bot", responses["billing"]))
    st.session_state.awaiting_order_id = True
    st.rerun()

if col2.button("📦 Shipping"):
    st.session_state.messages.append(("You", "Where is my package?"))
    st.session_state.messages.append(("Bot", responses["shipping"]))
    st.session_state.awaiting_tracking_id = True
    st.rerun()

if col3.button("🛠️ Technical"):
    st.session_state.messages.append(("You", "My app keeps crashing"))
    st.session_state.messages.append(("Bot", responses["technical support"]))
    st.rerun()

if col4.button("💰 Pricing"):
    st.session_state.messages.append(("You", "Tell me about your plans"))
    st.session_state.messages.append(("Bot", responses["pricing"]))
    st.rerun()

if col5.button("📊 Compare Plans"):
    st.session_state.messages.append(("You", "What is the difference between your plans?"))
    st.session_state.messages.append(("Bot", responses["pricing_diff"]))
    st.rerun()

# --- Clear Chat Button ---
st.subheader("⚙️ Controls")
if st.button("🗑️ Clear Chat"):
    for key in list(st.session_state.keys()):
        del st.session_state[key]
    st.success("Chat history cleared! Please start a new conversation.")
    st.rerun()

!pip install pyngrok

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import nltk
# from nltk.corpus import stopwords
# from nltk.stem import WordNetLemmatizer
# from nltk.tokenize import word_tokenize
# 
# # Download NLTK resources
# nltk.download("punkt")
# nltk.download("stopwords")
# nltk.download("wordnet")
# 
# # --- NLP Setup ---
# lemmatizer = WordNetLemmatizer()
# stop_words = set(stopwords.words("english"))
# 
# def preprocess(text):
#     tokens = word_tokenize(text.lower())
#     tokens = [lemmatizer.lemmatize(word) for word in tokens if word.isalpha() and word not in stop_words]
#     return tokens
# 
# # Categories
# categories = {
#     "billing": ["refund", "payment", "invoice", "bill", "price", "premium"],
#     "shipping": ["shipping", "delivery", "package", "order", "tracking"],
#     "technical support": ["error", "crash", "bug", "issue", "problem", "device"],
#     "pricing": ["price", "cost", "premium", "subscription", "plan", "difference", "compare"],
# }
# 
# # Responses
# responses = {
#     "billing": "💳 I understand you have a billing issue. Can you provide your order ID?",
#     "shipping": "📦 Looks like a shipping issue. Can you share your tracking number?",
#     "technical support": "🛠️ It looks like a technical issue. Can you tell me which device you are using?",
#     "pricing": "💰 Our Premium plan is $10/month and Standard plan is $5/month.",
#     "pricing_diff": "📊 The Standard plan gives you basic features for $5/month, while Premium offers advanced features, faster support, and extra tools for $10/month.",
#     "default": "🤔 Sorry, I’m not sure about that. Could you rephrase?",
# }
# 
# # Classification
# def classify(text):
#     tokens = preprocess(text)
# 
#     # Special handling for pricing comparison
#     if any(word in text.lower() for word in ["difference", "compare", "vs", "better"]):
#         return "pricing_diff"
# 
#     scores = {cat: 0 for cat in categories}
#     for cat, keywords in categories.items():
#         for word in tokens:
#             if word in keywords:
#                 scores[cat] += 1
#     return max(scores, key=scores.get) if max(scores.values()) > 0 else "default"
# 
# # --- Streamlit App ---
# st.set_page_config(page_title="Smart Chatbot", page_icon="🤖", layout="centered")
# st.title("💬 Customer Support Chatbot")
# 
# # Initialize session
# if "messages" not in st.session_state:
#     st.session_state.messages = []
# if "awaiting_order_id" not in st.session_state:
#     st.session_state.awaiting_order_id = False
# if "awaiting_tracking_id" not in st.session_state:
#     st.session_state.awaiting_tracking_id = False
# 
# # Show chat history
# for sender, msg in st.session_state.messages:
#     if sender == "You":
#         st.markdown(f"**🧑 You:** {msg}")
#     else:
#         st.markdown(f"**🤖 Bot:** {msg}")
# 
# # --- Chat input ---
# user_input = st.chat_input("Type your message...")
# 
# if user_input:
#     st.session_state.messages.append(("You", user_input))
# 
#     # --- Refund Order ID Flow ---
#     if st.session_state.awaiting_order_id:
#         if user_input.isdigit():
#             st.session_state.messages.append(("Bot", "✅ I have forwarded your refund request. You will get a notification in 2 - 3 days."))
#             st.session_state.messages.append(("Bot", "ℹ️ Is there anything else I can help you with?"))
#             st.session_state.awaiting_order_id = False
#         else:
#             st.session_state.messages.append(("Bot", "❌ That doesn’t look like a valid order ID. Please enter a number."))
# 
#     # --- Shipping Tracking ID Flow ---
#     elif st.session_state.awaiting_tracking_id:
#         if user_input.isdigit():
#             st.session_state.messages.append(("Bot", f"📦 Tracking ID {user_input} found. Your package is being processed."))
#             st.session_state.messages.append(("Bot", "ℹ️ Is there anything else I can help you with?"))
#             st.session_state.awaiting_tracking_id = False
#         else:
#             st.session_state.messages.append(("Bot", "❌ That doesn’t look like a valid tracking number. Please enter digits only."))
# 
#     else:
#         if user_input.lower() in ["quit", "exit"]:
#             st.session_state.messages.append(("Bot", "👋 Goodbye!"))
#         else:
#             category = classify(user_input)
#             bot_response = responses.get(category, responses["default"])
#             st.session_state.messages.append(("Bot", bot_response))
# 
#             # If refund detected → wait for order ID next
#             if category == "billing" and "refund" in user_input.lower():
#                 st.session_state.awaiting_order_id = True
# 
#             # If shipping detected → wait for tracking ID next
#             if category == "shipping":
#                 st.session_state.awaiting_tracking_id = True
# 
#     st.rerun()
# 
# # --- Quick Reply Buttons ---
# st.subheader("Quick Replies")
# col1, col2, col3, col4, col5 = st.columns(5)
# 
# if col1.button("💳 Billing"):
#     st.session_state.messages.append(("You", "I have a billing issue"))
#     st.session_state.messages.append(("Bot", responses["billing"]))
#     st.session_state.awaiting_order_id = True
#     st.rerun()
# 
# if col2.button("📦 Shipping"):
#     st.session_state.messages.append(("You", "Where is my package?"))
#     st.session_state.messages.append(("Bot", responses["shipping"]))
#     st.session_state.awaiting_tracking_id = True
#     st.rerun()
# 
# if col3.button("🛠️ Technical"):
#     st.session_state.messages.append(("You", "My app keeps crashing"))
#     st.session_state.messages.append(("Bot", responses["technical support"]))
#     st.rerun()
# 
# if col4.button("💰 Pricing"):
#     st.session_state.messages.append(("You", "Tell me about your plans"))
#     st.session_state.messages.append(("Bot", responses["pricing"]))
#     st.rerun()
# 
# if col5.button("📊 Compare Plans"):
#     st.session_state.messages.append(("You", "What is the difference between your plans?"))
#     st.session_state.messages.append(("Bot", responses["pricing_diff"]))
#     st.rerun()
# 
# # --- Clear Chat Button ---
# st.subheader("⚙️ Controls")
# if st.button("🗑️ Clear Chat"):
#     for key in list(st.session_state.keys()):
#         del st.session_state[key]
#     st.success("Chat history cleared! Please start a new conversation.")
#     st.rerun()
#

from pyngrok import ngrok
ngrok.set_auth_token("31aAnHbHLQP2xbVndyp7nKncsil_2BemcA4Ky5oVaDck58Xfj")

import subprocess
from pyngrok import ngrok

# Kill previous tunnels if any
ngrok.kill()

# Start tunnel
public_url = ngrok.connect(8501)
print("🚀 Streamlit app running at:", public_url)

# Run your app
subprocess.Popen(["streamlit", "run", "app.py"])